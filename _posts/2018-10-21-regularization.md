---
layout:     post                    # 使用的布局（不需要改）
title:      DL之正则化               # 标题 
subtitle:   解决过拟合 #副标题
date:       2018-10-21              # 时间
author:     ERAF                      # 作者
header-img: img/nanase_20.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 深度学习
---
忽然发现 对于正则化的总结忘记放上去了，或者与其说是正则化，倒不如说是常见的解决过拟合的方法；
>话说 忽然感觉总自己写的东西 其实总有点内在联系的 连在一起看，总有点似曾相识的感觉；


## 过拟合的定义

如果说**欠拟合**是指**模型**并不能在**训练集**上有着足够低的训练误差；那么**过拟合**指模型的**训练误差**（经验误差）与**测试误差**（泛化误差）之间差距过大； 「反映在**评价指标**上，就是模型在训练集上表现良好，但是在测试集和新数据上表现一般（**泛化能力差**） 」

进而说 规则化的参数是为了防止过分拟合训练数据；所以我们相当于**保证模型简单的基础上进行最小化训练误差**，而这种保证简单就是借助规则函数等操作来实现的；从这个角度来看 ：**规则项的使用相当于人们对于模型的先验知识的加入，使模型具有人们想要的特性。**

## 常见的降低过拟合的方法

### 权值约束

也就是添加正则项的操作，一般来说 就是相当于给予参数惩罚项；限制模型的学习能力、限制权重的规模，进而使模型偏好于权值较小的目标函数 防止过拟合；

这里就带来一个问题就是：

#### 为什么不对偏置做权重惩罚

因为一般来说：每个偏置只影响一个变量，而且需要很少的数据就完整了精确拟合；每个偏置只影响一个变量，而且需要很少的数据就完整了精确拟合；

常见的惩罚项包括**L1和L2范数**；两者都可以**给予模型倾向于较小复杂度模型的先验**，限制模型的大小和学习能力，通过限制参数的规模，进而使模型偏好于权值较小的目标函数，防止过拟合。

但是不同之处在于：**L1可以产生稀疏权重**，也就说得到的最优解会有更多的0作为参数，进而减小了模型复杂度。**可以用于特征选择**；而L2的方法只能用于防止模型过拟合；

### 为什么 L1 正则化可以产生稀疏权值，而 L2 不会？

添加 L1 正则化，相当于在 L1范数的约束下求目标函数 J 的最小值，下图展示了二维的情况：

![](D:/Document/Algorithm_Interview_Notes-Chinese-master/Algorithm_Interview_Notes-Chinese-master/_assets/TIM%E6%88%AA%E5%9B%BE20180608171710.png)

图中 J 与 L 首次相交的点就是最优解。L1 在和每个坐标轴相交的地方都会有“角”出现（多维的情况下，这些角会更多），在角的位置就会产生稀疏的解。而 J 与这些“角”相交的机会远大于其他点，因此 L1 正则化会产生稀疏的权值。

类似的，可以得到带有 L2正则化的目标函数在二维平面上的图形，如下：

![](D:/Document/Algorithm_Interview_Notes-Chinese-master/Algorithm_Interview_Notes-Chinese-master/_assets/TIM%E6%88%AA%E5%9B%BE20180608172312.png)

相比 L1，L2 不会产生“角”，因此 J 与 L2 相交的点具有稀疏性的概率就会变得非常小。

### 数据增强

也就是说提供更多的数据来进行训练，提高泛化能力。常见的 图像数据进行平移旋转和缩放得到新的数据；NLP使用机器翻译得到新的数据，还有就是使用生成对抗网络来生成新的数据「$min_Gmax_DV(D,G)=E_{x~p_{data}(x)}[logD(x)]+E_{z~p_z(z)}[log(1-D(G(z)))]$」 

同时给输入加入一些噪声 也是提高鲁棒性的操作；而**注入方差较小的噪声的行为在某些模型等价于给权重施加范数惩罚**；此外还有RNN中 给权重施加噪声；

### 降低模型复杂度

既然模型拟合的太过分，进而导致的过拟合，于是就对模型进行变得简单一些；常见的包括：神经网络 减少网络层 减少单元；决策树 减少树的深度 剪枝；

### 集成学习和dropout

这两者被放在一起说了，毕竟dropout经常被看做一种bagging的方法来进行正则化；此外 还有常见的直接采用bagging的方法进行的集成学习，集合几个模型显著降低泛化误差；思路基本是基于相同的整个数据集进行随机采样，其中包含大量重复数据 并行训练出来多个模型 进而基于多数投票等方式得到结果，若模型相互关联最终一样，那么方差就都相等，若独立 则方差平均 。事实上 大部分时候都是介于中间，因而可以降低方差「boosting是将模型累加后 降低误差 不降低方差」

### 提前终止和多任务学习

**「等测试误差不再减少 就停止任务」**过拟合的现象就是训练误差越来越小，而测试误差与训练误差的间距越来越大，即测试误差先从大变小，然后有从小变大，在某一临界点出，达到最佳的测试误差。而这个临界点就由验证集的测试误差来确定。在训练模型的过程中，每迭代一定的次数就求取验证集的测试误差，如果每次验证集的误差有所改善，就存储模型参数；当验证集的误差在事先制定的允许次数内没有进一步的改善，就终止算法，最终返回模型参数。

 **多任务学习** 通过合并多个任务中的示例 来完成一种类似于给参数施加软约束的方式提高泛化性能；还有除了上面说到的权重衰减惩罚参数模型 可以有**稀疏化激活单元** 完成对于模型参数的间接惩罚；

## dropout「一般加在输出层比如激活函数前后 想想它的实现就知道了」

### 大大增加训练时间 但对测试时间几乎没什么影响

虽然按照描述 我们实现dropout的时候 需要找到相关的子网络 根据其预测来生成一个概率分布，集成的预测有分布的平均值给出 进而确定最终权重 来得到输出；显然这种操作 费时费力几乎不可能实现；因而常见的操作 还是**权重比例推断规则**「对某单元的输出权重乘上单元被包含的概率 来得到其应有的输出的期望值」



**具体实现来说：**每次某单元输出的时候 都是依据概率来判断这个单元是不是有输出「就是那个0.5之类的参数」如果不应该有 就对输出乘上0，完成对于这些单元的屏蔽；屏蔽完成后就是按照这里所说的权重推断比重 进行除以p「就是乘上倒数」 「这个时候是训练」；或者就是当测试的时候 对于权重进行乘上p；「原因也就是上面所说 毕竟不可能求全部的网络 然后对其均值得到概率分布，只能借助这个概率来体现应有输出的期望值」

### 权重比例推断规则

-   权重比例推断规则的目的是确保 在测试时一个单元的期望总输入与在训练时该单元的期望总输入大致相同。 
-   实践时，如果使用 `0.5` 的采样概率，**权重比例规则**相当于在训练结束后**将权重除 2**，然后像平常一样使用模型；等价的，另一种方法是在训练期间将单元的状态乘 2。

### dropout和bagging的关系

首先是复习一下**集成学习和bagging方法**：至少对于bagging来说，其主要想法是分别并行训练几个不同的模型，然后让所有模型表决测试样例的输出。这是机器学习中常规策略的一个例子，被称为**模型平均**（model averaging）。采用这种策略的技术被称为**集成方法**。

模型平均（model averaging）**奏效的原因**是不同的模型通常不会在测试集上产生完全相同的误差。平均上， 集成至少与它的任何成员表现得一样好，并且**如果成员的误差是独立的**，集成将显著地比其成员表现得更好。

具体来说，Bagging 涉及构造 k 个**不同的数据集**。每个数据集从原始数据集中**重复采样**构成，和原始数据集具有**相同数量**的样例。这意味着，每个数据集以高概率缺少一些来自原始数据集的例子，还包含若干重复的例子（更具体的，如果采样所得的训练集与原始数据集大小相同，那所得数据集中大概有原始数据集 **2/3** 的实例）

### dropout强大的原因

简单来说，dropout借助于**参数共享的方式**达到了一种bagging集成近似，能够训练评估指数级数量的神经网络；也就是说 dropout里面 我们只是训练一部分的模型的参数，借助参数共享使其余的子网络得到很好的参数设置；

具体来说 我们每次只是从原有网络中 采取子网络进行训练，比如常说的**隐藏层**的采样概率为 0.5，**输入**的采样概率为 0.8；**实现的时候 更多的只是将一些单元的输出乘上0就能有效的删除一个单元**，于是**dropout 也被看做一种对于施加到隐藏单元的噪声**，毕竟隐层相当于来自于输入的特征提取，直接对于某些乘上0 相当于抹去这些特征；「使模型变得简单？」

**Dropout与Bagging的不同点**：

-   在 Bagging 的情况下，所有模型都是独立的；而在 Dropout 的情况下，所有模型**共享参数**，其中每个模型继承父神经网络参数的不同子集。
-   在 Bagging 的情况下，每一个模型都会在其相应训练集上训练到收敛。而在 Dropout 的情况下，通常大部分模型都没有显式地被训练；取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。

Dropout训练与Bagging训练不太一样。在Bagging的情况下,所有模型是独立 的。在Dropout的情况下,模型是共享参数的,其中每个模型继承的上一个神经网络参数的不同子集。参数共享使得在有限可用的内存下代表指数数量的模型变得可能。 在Bagging的情况下,每一个模型在其相应训练集上训练到收敛。在Dropout的情况下,通常大部分模型都没有显式地被训练,通常该模型很大,不可能采样所有可能的子网络。取而代之的是,可能的子网络的一小部分训练单个步骤,参数共享导致剩余的子网络能有好的参数设定。这些是仅有的区别。除了这些,Dropout与Bagging算法一样。例如,每个子网络中遇到的训练集确实是替换采样的 原始训练集的一个子集。